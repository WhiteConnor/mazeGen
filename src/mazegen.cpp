#include <chrono>
#include <iostream>
#include <string>
#include <stdio.h>
#include <random>
#include <cstring>
#include "MurmurHash3.h"
#include <bitset>
#include <bits/stdc++.h>
#include <thread>
#include "Node.h"
#include "ThreeCoord.h"
#include "mazeUtils.h"
#include "LinkedNode.h"

ThreeCoord<int> halls;

int main(int argc, char *argv[])
{
  // Ensure
  if (!(argc == 4 || argc == 5)) {
    printf("argc: %d\n", argc);
    printf("Usage: %s <int x_halls> <int y_halls> <int z_halls> <seed>\n", argv[0]);
    return 1;
  }
  
  try
  {
    halls.x = std::stoi(argv[1]);
    halls.y = std::stoi(argv[2]);
    halls.z = std::stoi(argv[3]);
  }
  catch (const std::invalid_argument &e)
  {
    printf("Invalid argument: %s\n", e.what());
    printf("Usage: %s <int x_halls> <int y_halls> <int z_halls> <seed>\n", argv[0]);
    return 1;
  }
  catch (const std::out_of_range &e)
  {
    printf("Out of range: %s\n", e.what());
    printf("Usage: %s <int x_halls> <int y_halls> <int z_halls> <seed>\n", argv[0]);
    return 1;
  }
  
  
  std::random_device rd;  // Obtain a random number from hardware
  std::mt19937 gen;       // merser twister engine

  if (argc != 5)
  {
    printf("Using random seed.\n");
    gen = std::mt19937(rd());
  }
  else
  {
    printf("Hashing input to create seed.\n");
    uint32_t seed;
    MurmurHash3_x86_32(argv[4],std::strlen(argv[4]),0,&seed); // Use murmurHash3_x86_32 for consistency across platforms, see readme
    gen = std::mt19937(seed); // Nice clean deterministic generator
    printf("Seed: %u\n", seed);
  }

  std::uniform_int_distribution<> dis(0, 59); // 60 is lowest common multiple of 1-6, 0-59 for 60 options, only one generator => avoid branching

  // W H W H W
  // D.x = 5, D.y = 5
  // 0 0 0 0 0   W
  // 0 2 1 2 0   H
  // 0 1 0 1 0   W
  // 0 2 0 2 0   H
  // 0 0 0 0 0   W

  // Every corridor (where a vertical and horizontal hall cross, marked 2) will always be open at the end
  // Every wall cornered by a 2 will always be closed
  // Walls between ( Vertical/Horizontal ) can be open or closed
  // A maze can be considered perfect if every pair of points is reachable through one path
  // A perfect maze can be generated by starting a random walk from any previously visited cell
  // Walls are opened one step at a time

  // Width = halls * 2 + 1
  
  ThreeCoord<int> d = ThreeCoord((halls.x * 2) + 1, (halls.y * 2) + 1, (halls.z * 2) + 1);
  
  // Create a uint8_t maze array
  uint8_t *maze = new uint8_t[d.vol()];
  // Ensure that maze is initialized to zero
  std::memset(maze, 0, d.vol());

  // Start in the corner
  ThreeCoord<int> cursor = ThreeCoord(halls.x / 2, halls.y / 2, halls.z / 2);
  cursor.x = (cursor.x * 2) + 1;
  cursor.y = (cursor.y * 2) + 1;
  cursor.z = (cursor.z * 2) + 1;
  *(maze + access(cursor, d)) = 1; // init maze

  LinkedNode list = LinkedNode(cursor);

  // Each corridor requires one transition in, and with one initialized corridor, there will be exactly (x * y * z) - 1 steps
  // There will be exactly (x * y * z) corridors
  // from here searching for a corridor is an expensive task (time wise)
  // Implement a list that keeps track of all corridors that have been visited but still have available locations
  // This will allow for parallelism using atomic operations in the future
  auto t1 = std::chrono::high_resolution_clock::now();
//  Even though there will only be (x * y * z) - 1 steps, every corridor can block 6 hallways
//  This means that some halls may not have any available locations and a step will be skipped
//  Therefore, we will run the loop until the linked list is empty
  // if cursor has available locations and not reached 10 steps steps, step cursor, otherwise if cursor has
  // no available locations remove from list and choose new
  // else if reached 10 steps choose new
  for (int i = 0; i < halls.vol() - 1; i++) {
    if ((i % 10) == 9) {
      cursor = step(maze, cursor, d, gen, dis, list);
    } else {
      cursor = ThreeCoord<int>(0,0,0);
    }
    while (!cursor) {
      if (list.getNodeCount() == 0) {
        i = halls.vol();
        break;
      }
      cursor = list.getRandom(gen);
      cursor = step(maze, cursor, d, gen, dis, list);
    }
    if (cursor) {
      list.append(cursor);
    }
  }
  auto t2 = std::chrono::high_resolution_clock::now();
  std::chrono::duration<float, std::milli> fp_ms = t2 - t1;
  printf("Time is: %f ms\n", fp_ms.count());
  printFlatMaze(maze, d, cursor);

  std::ofstream fileout("maze.mze");
  fileout << d.x << d.y << d.z;
  for (int i = 0; i < d.vol(); i++){
    fileout << *(maze + i);
  }

  delete[] maze;
  return 0;
}


// ./mazegen.x x y z seed

// TODO: Rewrite maze format to pack 4-bit VRBD flags per corridor using 32-bit ints for 8-way compressed spatial encoding